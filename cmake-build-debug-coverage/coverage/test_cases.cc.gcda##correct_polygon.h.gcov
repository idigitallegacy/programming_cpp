        -:    0:Source:/mnt/d/labs_prog_cpp/lab1/class/correct_polygon.h
        -:    0:Graph:/mnt/d/labs_prog_cpp/lab1/cmake-build-debug-coverage/CMakeFiles/main_test.dir/test_cases.cc.gcno
        -:    0:Data:/mnt/d/labs_prog_cpp/lab1/cmake-build-debug-coverage/CMakeFiles/main_test.dir/test_cases.cc.gcda
        -:    0:Runs:1
        -:    1://
        -:    2:// Created by Михаил on 09.02.2021.
        -:    3://
        -:    4:
        -:    5:#ifndef LABS_PROGRAMMING_CORRECTPOLYGON_H
        -:    6:#ifdef LABS_PROGRAMMING_POLYGON_H
        -:    7:
        -:    8:#define LABS_PROGRAMMING_CORRECTPOLYGON_H
        -:    9:
        -:   10:class CorrectPolygon : public Polygon {
        -:   11:private:
        -:   12:    /// Checks if [source] is a correct polygon
function _ZN14CorrectPolygon16check_if_correctERKSt6vectorI5PointSaIS1_EE called 2 returned 100% blocks executed 54%
        2:   13:    static bool check_if_correct(const std::vector<Point> &source) {
        2:   14:        if (source.size() < 3)
        2:   14-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:   15:            throw FigureException("Too few points to initialize a polygon", TOO_FEW_POINTS);
    %%%%%:   15-block  0
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    %%%%%:   15-block  1
call    5 never executed
branch  6 never executed
branch  7 never executed
    %%%%%:   15-block  2
call    8 never executed
call    9 never executed
call   10 never executed
    $$$$$:   15-block  3
call   11 never executed
    $$$$$:   15-block  4
    $$$$$:   15-block  5
call   12 never executed
    $$$$$:   15-block  6
    $$$$$:   15-block  7
call   13 never executed
        -:   16:
        2:   17:        if (!check_if_convex(source))
        2:   17-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:   18:            throw FigureException("New shape is not convex", NOT_CONVEX);
    %%%%%:   18-block  0
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    %%%%%:   18-block  1
call    5 never executed
branch  6 never executed
branch  7 never executed
    %%%%%:   18-block  2
call    8 never executed
call    9 never executed
call   10 never executed
    $$$$$:   18-block  3
call   11 never executed
    $$$$$:   18-block  4
    $$$$$:   18-block  5
call   12 never executed
    $$$$$:   18-block  6
    $$$$$:   18-block  7
call   13 never executed
        -:   19:
       10:   20:        for (long long i = 0; i < source.size(); ++i) {
        2:   20-block  0
       10:   20-block  1
call    0 returned 10
branch  1 taken 8 (fallthrough)
branch  2 taken 2
        8:   20-block  2
        8:   21:            if (!check_if_unique(source, i, source[i]))
        8:   21-block  0
call    0 returned 8
call    1 returned 8
branch  2 taken 0 (fallthrough)
branch  3 taken 8
    #####:   22:                return false;
    %%%%%:   22-block  0
        -:   23:        }
        -:   24:
        2:   25:        double length = 0;
       10:   26:        for (int i = 0; i < source.size(); ++i) {
        2:   26-block  0
       10:   26-block  1
call    0 returned 10
branch  1 taken 8 (fallthrough)
branch  2 taken 2
        8:   26-block  2
        8:   27:            double tmp = std::sqrt((source[i + 1].getX() - source[i].getX())
        8:   27-block  0
call    0 returned 8
call    1 returned 8
call    2 returned 8
call    3 returned 8
        8:   28:                                   * (source[i + 1].getX() - source[i].getX())
call    0 returned 8
call    1 returned 8
call    2 returned 8
call    3 returned 8
        8:   29:                                   + (source[i + 1].getY() - source[i].getY())
call    0 returned 8
call    1 returned 8
call    2 returned 8
call    3 returned 8
        8:   30:                                     * (source[i + 1].getY() - source[i].getY()));
call    0 returned 8
call    1 returned 8
call    2 returned 8
call    3 returned 8
        8:   31:            if (i == 0) {
branch  0 taken 2 (fallthrough)
branch  1 taken 6
        2:   32:                length = tmp;
        2:   33:                continue;
        2:   33-block  0
        -:   34:            }
       6*:   35:            if (length != tmp) return false;
        6:   35-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    %%%%%:   35-block  1
        -:   36:        }
        2:   37:        return true;
        2:   37-block  0
        -:   38:    }
        -:   39:
        -:   40:public:
        -:   41:    /// Changing point comes to incorrect polygon, so it's prohibited
function _ZN14CorrectPolygon12change_pointERK5Pointdd called 0 returned 0% blocks executed 0%
    #####:   42:    void change_point(const Point &source, const double new_x, const double new_y) override {
    #####:   43:        throw FigureException("Changing points at the correct polygon is not allowed", CHANGING_POINT_IS_NOT_ALLOWED);
    %%%%%:   43-block  0
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    %%%%%:   43-block  1
call    5 never executed
branch  6 never executed
branch  7 never executed
    %%%%%:   43-block  2
call    8 never executed
call    9 never executed
call   10 never executed
    $$$$$:   43-block  3
call   11 never executed
    $$$$$:   43-block  4
    $$$$$:   43-block  5
call   12 never executed
    $$$$$:   43-block  6
    $$$$$:   43-block  7
call   13 never executed
        -:   44:    };
        -:   45:
        -:   46:    /// Adds a multiplier to points coordinates. E.g. Point(2;3) after CorrectPolygon.reshape(2) becomes (4;6)
        -:   47:    void reshape(const double multiplier) {
        -:   48:        if (multiplier == 0)
        -:   49:            throw FigureException("Invalid point multiplyer == 0", INVALID_POINT_MULTIPLYER);
        -:   50:        for (auto &i : points_) {
        -:   51:            i.setX(i.getX() * multiplier);
        -:   52:            i.setY(i.getY() * multiplier);
        -:   53:        }
        -:   54:    }
        -:   55:
        -:   56:    explicit CorrectPolygon(const Point pts[], const unsigned long long count = 0) : Polygon(pts, count) {
        -:   57:        if (!check_if_correct(points_))
        -:   58:            throw FigureException("New polygon is arbitrary.", ARBITRARY_POLYGON);
        -:   59:    }
        -:   60:
function _ZN14CorrectPolygonC2ERKSt6vectorI5PointSaIS1_EE called 2 returned 100% blocks executed 24%
        2:   61:    explicit CorrectPolygon(const std::vector<Point> &pts) : Polygon(pts) {
        2:   61-block  0
call    0 returned 2
    $$$$$:   61-block  1
call    1 never executed
        2:   62:        if (!check_if_correct(pts))
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:   62-block  0
branch  3 taken 0 (fallthrough)
branch  4 taken 2
    #####:   63:            throw FigureException("New polygon is arbitrary.", ARBITRARY_POLYGON);
    %%%%%:   63-block  0
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    %%%%%:   63-block  1
call    5 never executed
branch  6 never executed
branch  7 never executed
    %%%%%:   63-block  2
call    8 never executed
call    9 never executed
call   10 never executed
    $$$$$:   63-block  3
call   11 never executed
    $$$$$:   63-block  4
    $$$$$:   63-block  5
call   12 never executed
    $$$$$:   63-block  6
    $$$$$:   63-block  7
call   13 never executed
        2:   64:    }
        2:   64-block  0
        -:   65:
        -:   66:    explicit CorrectPolygon(const Polygon &source) : Polygon(source) {
        -:   67:        if (!check_if_correct(source.get_polyline()))
        -:   68:            throw FigureException("New polygon is arbitrary.", ARBITRARY_POLYGON);
        -:   69:    }
        -:   70:
        -:   71:    // Copy constructor
        -:   72:    CorrectPolygon(const CorrectPolygon &source) noexcept : Polygon(source.get_polyline()) {
        -:   73:        points_ = source.points_;
        -:   74:    }
        -:   75:
        -:   76:    CorrectPolygon &operator=(const CorrectPolygon &source) {
        -:   77:        if (!check_if_correct(source.get_polyline()))
        -:   78:            throw FigureException("New polygon is arbitrary.", ARBITRARY_POLYGON);
        -:   79:        points_ = source.get_polyline();
        -:   80:        return *this;
        -:   81:    }
        -:   82:
function _ZN14CorrectPolygonD2Ev called 2 returned 100% blocks executed 100%
        2:   83:    ~CorrectPolygon() = default;
        2:   83-block  0
call    0 returned 2
        -:   84:};
        -:   85:
        -:   86:#endif //LABS_PROGRAMMING_POLYGON_H
        -:   87:#endif //LABS_PROGRAMMING_CORRECTPOLYGON_H
